//! qdrant_client.rs
//!
//! Lightweight Qdrant client for upserting points in batches with retries.
//! - Assumes a *single* vector per point (simple collection schema).
//! - Uses string UUID point IDs generated by id_generator.
//! - Payload is any arbitrary data.
//!
//! Notes:
//! - Upsert endpoint: POST /collections/{name}/points?wait=true
//! - Batch & retry: simple exponential backoff.

use std::{thread, time::Duration};

use reqwest::StatusCode;
use serde::{Deserialize, Serialize};
use serde_json::{Value as JsonValue, json};
use thiserror::Error;

#[derive(Error, Debug)]
pub enum QdrantError {
    #[error("http: {0}")]
    Http(#[from] reqwest::Error),

    #[error("server returned {status}: {body}")]
    Status { status: StatusCode, body: String },

    #[error("serialization: {0}")]
    Serde(#[from] serde_json::Error),
}

#[derive(Clone)]
pub struct QdrantClient {
    http: reqwest::Client,
    base_url: String,
}

impl QdrantClient {
    pub fn new() -> Result<Self, QdrantError> {
        let http = reqwest::Client::builder()
            .timeout(Duration::from_secs(60))
            .build()?;
        Ok(Self {
            http,
            base_url: "http://localhost:6333".into(),
        })
    }

    fn upsert_url(&self, collection: &str) -> String {
        format!("{}/collections/{}/points", self.base_url, collection)
    }

    /// Upsert a batch of points, with simple retry/backoff per batch.
    ///
    /// - `batch_size`: how many points to send per request (e.g., 64/128).
    /// - `max_retries`: retries per batch on non-4xx errors.
    pub async fn upsert_points_batched(
        &self,
        collection: &str,
        points: Vec<PointWrite>,
        batch_size: usize,
        max_retries: usize,
    ) -> Result<(), QdrantError> {
        if points.is_empty() {
            return Ok(());
        }

        let mut start = 0usize;
        while start < points.len() {
            let end = (start + batch_size).min(points.len());
            let slice = &points[start..end];
            self.upsert_with_retry(collection, slice, max_retries)
                .await?;
            start = end;
        }
        Ok(())
    }

    async fn upsert_with_retry(
        &self,
        collection: &str,
        batch: &[PointWrite],
        max_retries: usize,
    ) -> Result<(), QdrantError> {
        let mut attempt = 0usize;
        loop {
            match self.upsert_once(collection, batch).await {
                Ok(_) => return Ok(()),
                Err(e) => {
                    // For 4xx (client) errors, retries likely won't help.
                    if let QdrantError::Status { status, .. } = &e {
                        if status.is_client_error() {
                            return Err(e);
                        }
                    }
                    attempt += 1;
                    if attempt > max_retries {
                        return Err(e);
                    }
                    let backoff_ms = 200u64.saturating_mul(2u64.pow(attempt as u32 - 1));
                    thread::sleep(Duration::from_millis(backoff_ms));
                }
            }
        }
    }

    pub async fn create_collection(&self, collection_name: &str) {
        let url = format!("http://localhost:6333/collections/{collection_name}");

        let request_body = json!({
          "vectors": {
            "size": 768,
            "distance": "Cosine"
          }
        });

        let response = self.http.put(url).json(&request_body).send().await.unwrap();

        if response.status().is_success() {
            let body: serde_json::Value = response.json().await.unwrap();
            println!("Success: {:?}", body);
        } else {
            let error_body = response.text().await.unwrap();
            eprintln!("Error: {:?}", error_body);
        }
    }

    async fn upsert_once(&self, collection: &str, batch: &[PointWrite]) -> Result<(), QdrantError> {
        let url = self.upsert_url(collection);
        let req = UpsertPointsRequest {
            points: batch.to_vec(),
        };

        let resp = self.http.put(url).json(&req).send().await?;
        if !resp.status().is_success() {
            let status = resp.status();
            let body = resp.text().await.unwrap_or_default();
            return Err(QdrantError::Status { status, body });
        }

        // Optionally parse and verify status:
        let data: UpsertResponse = resp.json().await?;
        if data.status.as_deref() != Some("ok") {
            // Defensive: Qdrant typically returns "ok"; if not, surface as error.
            return Err(QdrantError::Status {
                status: StatusCode::OK,
                body: format!("unexpected response: {:?}", data),
            });
        }
        Ok(())
    }
}

/// -----
/// Minimal request/response types
/// -----

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PointWrite {
    /// Deterministic string id (UUIDv5 recommended).
    pub id: String,
    /// Embedding vector (must match collection vector size).
    pub vector: Vec<f32>,
    /// Arbitrary payload (flat JSON recommended).
    pub payload: JsonValue,
}

#[derive(Debug, Serialize)]
struct UpsertPointsRequest {
    points: Vec<PointWrite>,
}

#[derive(Debug, Deserialize)]
struct UpsertResponse {
    status: Option<String>,
    // time, result, etc. omitted
}

#[cfg(test)]
mod tests {
    use super::*;
    use serde_json::json;

    #[test]
    fn can_serialize_upsert_body() {
        let pts = vec![PointWrite {
            id: "d2f6c9c4-fb2d-5f4a-8e11-6b1a3c0a5f00".to_string(),
            vector: vec![0.1, 0.2, 0.3],
            payload: json!({
                "repo": "svc_auth",
                "file_path": "src/lib.rs",
                "symbol_name": "foo",
                "type": "function",
                "line_start": 10u32,
                "line_end": 42u32
            }),
        }];
        let req = UpsertPointsRequest { points: pts };
        let s = serde_json::to_string(&req).unwrap();
        assert!(s.contains("\"points\""));
        assert!(s.contains("\"vector\""));
    }
}
